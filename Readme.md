# Polyphase Programmable Direct Digital Synthesizer Using Phase Rotation Interpolation

This repository contains code, documentation, and other related materials for the **Polyphase Programmable Direct Digital Synthesizer Using Phase Rotation Interpolation**, developed as part of my research work with the Mixed Signal Group at IIT Delhi, under the guidance of Dr. Kaushik Saha.


# 1. Overview

This document describes a Polyphase Direct Digital Synthesizer (DDS). The design generates precise, phase-continuous sine waves at the desired frequency relative to the clock frequency, without using large lookup tables. It employs the sinc function, phase rotation, and polyphase interpolation to produce smooth signals. 

# 2. Concepts
## 2.1. Polyphase 

In digital signal processing, polyphase decomposition refers to dividing a signal into multiple sub-sequences, each representing a distinct phase offset of the main signal. 

Mathematically:

$$x_k[m] = x[Mm + k], \quad k = 0, 1, \dots, M-1$$

Each $x_k[m]$ corresponds to a sub-sequence offset by $k$ samples. Together, these $M$ sequences reconstruct the original signal. In waveform synthesis, this translates to using multiple phase-offset sample of a periodic waveform - each representing a phase branch in multi-phase oscillator system.

## 2.2. Rectangular Window and Polyphase Reconstruction

In the time domain, when a rectangular signal is multiplied by a sine wave, the sine wave exists only during the time interval where the rectangular signal has a value of one. Outside this interval, the product becomes zero.

In the frequency domain, this relationship transforms differently: the rectangular function corresponds to a sinc function, while the sine wave corresponds to an impulse. Because multiplication in the time domain is equivalent to convolution in the frequency domain, the resulting spectrum is obtained by convolving the sinc function with the impulse. This convolution effectively shifts the center of the sinc function to the frequency bin position of the impulse.

$$X(f) = \text{Sinc} * \delta(f - f_0)$$

In the proposed design, the stored 512-point sinc function inherently contains all 512 discrete frequency bins. By leveraging this property, the desired sine wave can be generated by selecting the appropriate bin position and combining it with the <u>8-point polyphase reconstruction method</u>.

## 2.3. Coarse Phase Sampling

In the hardware implementation, the convolution operation is not explicitly performed. Instead, the effect of convolution is achieved through **circular shifting** of the stored sinc waveform.

The base waveform, labeled **SINC**, is stored in BRAM as a **512-point, 16-bit table which includes both real and imaginary values**. Each entry corresponds to a sample of the sinc function. When the user specifies a frequency bin, the system shifts the read pointer of the sinc data by that bin offset. This process is mathematically equivalent to performing a **circular convolution** between the sinc function and an impulse located at the chosen bin position.

$$x_b[n] = (\delta[n - b] * h[n]) = h[n - b]$$

To generate the **polyphase samples**, eight equally spaced points are read from the sinc waveform. The address pointer increments by **64** for each new phase sample. Once the address exceeds 512, it wraps around by subtracting 512, effectively implementing a **modulo-512 addressing scheme**. This ensures continuous phase progression and cyclic data access within the stored waveform.

## 2.4. Non-Idealities: Phase Error

Now that we have the 8-points, which is approximately equivalent to a single cycle of the desired sine wave (specific bin). If the signal is replicated $N$ times there might be phase error (spectral leakage). This is the non-ideality we have to deal with but this can easiliy overcome because the phase error accumulated linearly.

True Signal:

$$x[n] = A\sin(\omega_0 n + \phi_0)$$

If $L$ samples corresponding to one intended cycle are extracted and replicated then:

$$\Delta \Phi = \omega_0 L$$

If $L$ equals one true period, then $\Delta\Phi = 2\pi$. In practice, there is a residual mismatch:

$$\epsilon = \text{wrap}(\Delta\Phi - 2\pi)$$

where,

$$\text{wrap}(x) = ((x + \pi) \bmod 2\pi) - \pi$$

This $\epsilon$ represents the phase jump at each boundary.

| $\epsilon = 0$ |         Perfect alignment         |
| :------------: | :-------------------------------: |
| $\epsilon > 0$ | Sine advances in phase each cycle |
| $\epsilon < 0$ |       Sine lags each cycle        |

### 2.4.1. Phase Error: Correlation

The accumulated phase error after $N$ replications is:

$$\Phi_N = N\epsilon \; (\bmod 2\pi)$$

Thus, phase error does not average out - it adds linearly across replications. Because the same segment is replicated repeatedly, the boundary mismatch is perfectly correlated and deterministic:

$$\Phi_{N+1} - \Phi_N = \epsilon$$

This relation holds for all $N$, showing that periodic replication without correction leads to deterministic phase drift.

## 2.5. Inverse Fourier Transform and Phase Rotation Interpolation

Before the phase rotation interpolation is multiplied with the 8-point data samples that will be replicated $N$ times, they are converted from frequency domain to time domain using inverse Fourier transform. 

After that, each of the 8-base samples represents one polyphase component of the original 512-point sine wave. By applying incremental complex rotations to each base sample, all intermediate points are constructed at high precision.

$$s[n] = A_i \cdot e^{j\left(\frac{2\pi n}{512} + \phi_i\right)}, \quad n \in \text{segment } i$$

This approach is functionally equivalent to an 8-phase DDS, where each coarse phase bin acts as an individual oscillator generating a specific segment of the waveform. **The phase rotation factor, which varies for each bin position, was stored in BRAM along with its real and imaginary components. The complex multiplication was implemented using DSP multiplier IP cores.**
---
Each extracted point generates 64 interpolated samples through phase rotation multiplication using  $e^{j\theta}$, where $\theta = \frac{2\pi m}{512}$. **This process reconstructs a complete 512-point waveform from 8 base samples. The IFFT and phase multiplication require both the real and imaginary components from SINC and Phase Rotation; however, only the </u>real part is utilized in the final output</u>.** 
---
## 2.6. Frequency Generated

The output frequency $f_{out}$ is related to the FPGA clock frequency $f_{clk}$ by:

$$f_{out} = f_{clk} \cdot \frac{N_{bin}}{N_{table}}$$

# 3. Results

This technique allows the output frequency to be controlled through bin selection. The design was tested at a 50 MHz clock frequency, and the output data was captured using a Logic Analyzer. The 12-bit samples were then compared with the golden reference, yielding an effective number of bits (ENOB) of approximately 10 out of 12. Verification was carried out using the Nexys DDR3 Artix-7 board.

## 3.1. ENOB Calculation

The observed output has deviations of up to ±2 LSB (2-bit error) and behaves as **random noise**, we can approximate:

$$\text{ENOB} = 12 - \log_2(\sqrt{12}\,\sigma_e)$$

$$\sigma_e \approx \frac{2}{\sqrt{3}} \approx 1.155 \text{ LSB}$$

Then,

$$\text{ENOB} = 12 - \log_2(\sqrt{12} \times 1.155) = 12 - 2.0 = 10.0$$

Thus, the **ENOB ≈ 10 bits**, which corresponds to a SINAD of:

$$\text{SINAD} = 6.02 \times 10 + 1.76 = 61.96 \text{ dB}$$

Note that, through parallelization and pipelined phase rotation, the architecture can scale beyond **100 MHz** on modern FPGA devices. **This work was carried out with a focus on expanding the bin selection control to enable the generation of chirp signals for radar testing**.

---
End of Document
